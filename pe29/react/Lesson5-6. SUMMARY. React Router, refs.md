## React Router, refs

### Основы роутинга в Реакте

React Router - библиотека, которая позволяет осуществлять переход между разными страницами приложения без перезагрузки страницы. 

В данном случае роутер позволяет менять URL адрес в браузере, не перезагружая при этом страницу, а также менять наполнение приложения в зависимости от адреса, на котором мы сейчас находимся.

Существует библиотека `react-router` с базовым функционалом роутинга, и две конкретных реализации - `react-router-dom` и `react-router-native` (для мобильных приложений). При разработке Web приложения в React, для использования функционала роутинга нам нужно подключить только библиотеку `react-router-dom` - она переэкспортирует все функции из библиотеки `react-router`, которые реализованы там, и включает дополнительную реализацию именно для браузера.

На текущий момент последней стабильной версией React Router является версия 5.2. При этом альфа-версия React Router 6 была выпущена 1 февраля 2020 года. Но пока что 6 версия находится в бета тестировании, поэтому мы будем работать с пятой версией роутера. При работе с пятой версией роутера, любые материалы по 4 версии являются актуальными, так как между версиями 4 и 5 отличия минимальные, и существует полная обратная совместимость. Весь код, который работал в 4 версии, должен работать и в 5 версии. А вот между 3 и 4 версиями была значительная разница, и мануалы с 3 версией уже использовать нельзя.
   
### Подключение библиотеки React Router

Для подключения библиотеки, нам надо обернуть все наше приложение в один из компонентов, которые представляют реализацию роутера. Самых популярных реализации для SPA две:
 - `<HashRouter>` - хранит роут в URL после хеша (`#`). Ссылка будет выглядеть так: `host://#/route1/route2`. На сервер отправляется только часть перед хешем. При использовании хеш роутера, сервер немного легче настроить для раздачи страницы `index.html`. На практике рекомендуется использовать только для совместимости со старыми версиями браузеров, которые не поддерживают HTML5 history API.
 - `<BrowserRouter>` - хранит роут в полной классической ссылке. Ссылка будет выглядеть так: `host://route1/route2`. На сервер отправляется вся ссылка. При использовании SPA подхода, на любой неизвестный адрес сервер должен возвращать страницу `index.html` (либо на сервере придется дублировать все роуты фронт-енда).

Проще всего обернуть все наше приложение в функционал роутера в файле `index.js`.
   
```js
<BrowserRouter>
  <ErrorBoundary>
    <App />
  </ErrorBoundary>
</BrowserRouter>
```
   
### Создание роутов

Все роуты мы будем прописывать в обычном компоненте Реакта. Это лучше всего делать в отдельном компоненте, и помещать его в отдельную папку. Например, можно использовать папку `routes`, в которой создать компонент `AppRoutes`.
   
Конкретные роуты создаются с помощью компонента `<Route>`, который может принимать следующие свойства:
 - `path` - путь в адресной строке браузера, при котором компонент из данного роута будет показан на экране
 - `exact` - boolean свойство, которое говорит, должен ли адрес точно совпадать. Например, если свойство равно `false` (это значение по умолчанию), то роут с путем `/inbox` будет показан, если в адресной строке браузера будет написано и `/inbox/1`, и для любого подобного вложенного роута любого уровня
 - `component` - какой компонент надо показать на экране, если данный роут должен быть отрендерен
 - `render` - более гибкая функция рендеринга, которую можно передать вместо свойства `component`. Может использоваться, чтобы отрендерить компонент в роуте, но при этом передать ему дополнительные свойства: `render={() => <Inbox emails={emails} />}`
 - `children` - альтернатива `component` и `render`, позволяет передать компонент, который должен рендерить данный роут, между открывающим и закрывающим тегом `<Route>`

Далее, чтобы роутинг начал работать, достаточно отрендерить компонент `<AppRoutes>` где-нибудь в `App.js` или любом другом подходящем месте приложения.
   
### Создание ссылок для перехода между страницами

Если в нашем главном меню мы будем использовать классические теги `<a>`, при клике на него реакт роутер покажет нам другую страницу, но при этом вся страница будет перезагружена. Чтобы избежать перезагрузки страницы, нужно использовать специальный компонент `<Link>` из библиотеки `react-router-dom`. Данный компонент принимает параметр `to` (вместо `href` у обычной ссылки) для указания, на какую страницу должен совершаться переход.

Также есть более продвинутая форма данного компонента - компонент `<NavLink>`, который может дополнительно стилизовать текущую ссылку, если мы находимся на странице, которая соответствует текущему адресу в адресной строке браузера. Этот компонент может принимать такие дополнительные свойства:
 - `activeClassName` - какой класс добавить ссылке, если мы находимся по текущему адресу
 - `activeStyle` - какие стили добавить ссылке, если мы находимся по текущему адресу
 - `exact` - аналог ключевого слова `exact` для роутера. Показывает, должна ли ссылка точно совпадать для ее дополнительной стилизации, или также стилизовать ее и для вложенных путей

### Создание страницы 404

Роут для страницы 404 может выглядеть следующим образом:
   
```js
<Route path='*' component={Page404} />
```

В текущем варианте данная страница будет рендериться абсолютно всегда и на всех страницах приложения. Чтобы рендерить ее только если ни один другой путь не совпал, мы можем использовать компонент `<Switch>`:
   
```js
<Switch>
  // All other routes
  ...
  <Route path='*' component={Page404} />
</Switch>
```

Компонент <Switch> рендерит только первый совпавший роут, остальные игнорирует. Таким образом, только если ни один роут из списка не совпадет с текущим значением в адресной строке браузера, на экране будет показана страница 404.
   
### Использование переменных в роутинге

Для использование переменной в роуте мы можем использовать двоеточие перед именем переменной:

```js
<Route exact path='/inbox/:emailId' component={OneEmail} />
```

Данный роут будет отрабатывать для абсолютно любого значения в качестве переменной `emailId`.

Прочитать значение данной переменной из адресной строки в компоненте `OneEmail` мы можем с помощью `this.props.match.params`.

Все значения нам будут приходить в виде строк, даже если в адресной строке находится число.

### Дополнительный фунционал роутинга

Каждый раз, когда мы рендерим нашу страницу с помощью `<Route ... component={...}/>`, роутер будет добавлять в `props` нашего компонента три объекта:
 - `history` - объект, который представляет историю браузера. Содержит удобные вспомогательные методы `goBack()` (вернуться на предыдущую страницу), `goForward()` (перейти на следующую страницу в истории браузера, если мы до этого возвращались назад), `push(...)` (перейти на конкретную страницу, которую мы укажем)
 - `location` - объект, который дает больше деталей о том, по какому адресу мы сейчас находимся. Содержит такие свойства как `pathname` (путь из адресной строки), `search` (показывает все request параметры из адресной строки, который идут после `?`), `hash` (путь после хеша, используется при работе с `HashRouter`).
 - `match` - объект, который показывает, почему данный роут был отрендерен. Содержит такие свойства, как `isExact` (было ли точное свпадение адреса), `params` (объект, который содержит все переменные, которые использовались в пути роута), `path` (паттерн, по которому совпал роут), `url` (совпавшая часть URL)
   
Если рендерить наш компонент в роуте с помощью функции `render`, чтобы иметь доступ к данным объектам, нам руками надо добавить их в `props` компонента:

```js
<Route exact path='/inbox/:emailId' render={(routerProps) => <OneEmail emails={emails} {...routerProps} />} />
```

Второй вариант добавить эти три объекта в `props` любого компонента - обернуть его экспорт в функцию `withRouter`.
   
```js
export default withRouter(OneEmail)
```

### Хуки из библиотеки React Router

Библиотека React Router предоставляет также четыре хука, которые могут быть использованы для более удобного доступа к переменным `match`, `location` и `history`: 

 - useHistory - используется в компоненте для получения доступа к объекту `history`
 - useLocation - используется в компоненте для получения доступа к объекту `location`
 - useParams - используется в компоненте для получения доступа к объекту `params` из объекта `match`
 - useRouteMatch - специальный хук, который может быть использован дял получения переменной `match`, даже если текущий компонент не был обернут в `<Route>`. Может быть полезен для чтения переменных из адресной строки браузера в универсальных компонентах вроде `Sidebar` или `Header` 
      
### Программный редирект пользователя на другую страницу

Чтобы программно перенаправить пользователя на другую страницу, мы можем использовать компонент `<Redirect>`. При рендере данного компонента на экране, он мгновенно перенаправляет пользователя на страницу по адресу, который указывается с помощью свойства `to`. 

Данный компонент может использоваться для перенаправления залогиненного пользователя на главную страницу, или для редиректа незалогиненного пользователя на страницу логина

При использовании роутера существуют три основных способа направить пользователя на другую страницу:
 - Использовать `<Link>` или `<NavLink>` - если пользователь должен сам осуществить переход, кликнув по ссылке
 - Использовать `history.push()` - если переход осуществляется при каком-то действии пользователя, например, при нажатии кнопки, или если нам это надо сделать программно в одном из наших методов
 - Использовать компонент `<Redirect>` - если переход должен быть совершен при определенном условии после перерендера компонента (если вы прописываете эту логику внутри метода `render`), когда нам пришли новые свойства
   
### Защищенные роуты

Чтобы запретить незалогиненному пользователю попасть на страницу, которая доступна только для зарегистрированных пользователей, мы можем написать собственный компонент `ProtectedRoute`, который будет автоматически проверять права доступа пользователя:
   
```js
const ProtectedRoute = ({component: Component, render, authenticated, ...props}) => (
  <Route {...props} render={(routerProps) => {
    if (authenticated) {
      return !!render ? render(routerProps) : <Component {...routerProps} />
    }
         
    return <Redirect to='/login' />
  }} />
)
```

Вместо `render`/`component` можно тажке использовать `children`.
   
Используя данный компонент, все роуты могут быть переписаны очень просто:
   
```js
...
<ProtectedRoute exact path='/sent' authenticated={authenticated} component={Sent} />
...
```
   
Все роуты, доступные только зарегистрированным пользователям, должны вызываться с помощью `<ProtectedRoute>`. Роуты, доступные всем пользователям - с помощью стандартного компонента `<Route>`. При этом в каждый `<ProtectedRoute>` нам обязательно надо передать переменную `authenticated`.
   
### Прочее из роутинга

Библиотека `react-router` предоставляет компонент `<Prompt>` для выведения предупреждения пользователю пеерд переходом на другую страницу. Полезно, когда пользователь начал заполнять форму, но случайно нажал на закрытие страницы или переход на другую страницу - чтобы заполненные им данные не пропали

### Работа с ref

Чтобы в React компоненте получить доступ к DOM элементу, мы можем использовать функционал `ref`. 

При работе с классовыми компонентами, переменную для хранения ссылки на DOM элемент обычно создают в конструкторе класса:
   
```js
constructor(props) {
  super(props);

  this.loginRef = React.createRef();
}
```

При работе с функциональным компонентом, используется хук `useRef`:

```js
const loginRef = useRef();
````
   
После этого, чтобы при первом рендере в данную переменную была записана ссылка на DOM элемент, соответствующему элементу необходимо передать ее в качестве свойства `ref`:
   
```js
<input type='text' name='login' placeholder='Login' ref={this.loginRef} />

или для функционального компонента 

<input type='text' name='login' placeholder='Login' ref={loginRef} />
```

Внутреннее значение рефа будет обернуто в объект со свойством `current`. Доступ к самому DOM элементу можно будет получить, вызвав `loginRef.current`. 
   
Существует три способа создания рефов (второй и третий более старые и работают только для классовых компонентов):
 - С помощью `React.createRef()` / хука `useRef()`
 - С помощью функции-коллбека `ref={(input) => this.login = input}`
 - С помощью строкового литерала и последующего доступа внутри `this.refs` (`ref='login'`). Это старый способ, и его использования надо максимально избегать - это же советуют сами разработчики https://ru.reactjs.org/docs/refs-and-the-dom.html
       
Но, в общем случае, обращаться напрямую к DOM элементам не рекомендуется, и делать это нужно, только если нет другого способа решить задачу.
