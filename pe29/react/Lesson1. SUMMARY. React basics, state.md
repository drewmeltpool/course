## Основы React.js, работа с состоянием компонента

### Что такое React

React.js - современная библиотека для создания пользовательских интерфейсов.

Другие популярные библиотеки, которые предоставляют похожий функционал:
 - Angular
 - Vue.js

Создан инженерами из компании Facebook. Исходный код также находится в репозитории facebook - https://github.com/facebook/react

Основная "killer feature" библиотеки, за счет чего она изначально стала очень популярной - высокая скорость рендеринга за счет использования Virtual DOM. Это позволяет при каждом изменении вносить минимальное количество изменений в DOM дерево браузера.
 
### Создание приложения

Для быстрого создания приложения используется библиотека `create-react-app` - https://github.com/facebook/create-react-app
      
```
npx create-react-app my-app
cd my-app
```

    ВАЖНО!
    
    Ранее создание приложения происходило по-другому. Библиотеку `create-react-app` надо было устанавливать глобально, а потом создавать приложение следующим образом:
    
    npm install -g create-react-app
    create-react-app my-app
       
    Сейчас данный способ не работает. Более того, если библиотека `create-react-app` до сих пор установлена у вас глобально, то и новый способ не будет работать - он сгенерирует пустое приложение. Перед продолжением необходимо удалить старую версию библиотеки с помощью команды
       
    npm uninstall -g create-react-app

Данная команда устанавливает библиотеки `react` и `react-dom`, а также три библиотеки для тестирования (с ними познакомимся позже).
   
Также созданное приложение включает библиотеку `react-scripts`, которая предоставляет четыре готовых скрипта:
 - `start` - запуск приложения в dev режиме на порту 3000 (по умолчанию)
 - `build` - сборка приложения для деплоймента на сервере
 - `test` - запуск всех тестов в приложении
 - `eject` - выгрузка конфигурационных файлов Webpack в корень приложения. Одноразовое действие, после него нельзя будет автоматически обновить версию библиотеки `react-scripts`.

В папке `public` расположен файл `index.html`, а также прочие статические файлы, которые будут доступны в корне сервера (`localhost:3000/{filename.ext}`).

В папке `src` будет храниться весь наш исходный код. Например, вся работа React начинается с файла `index.js` внутри папки `src`. Метод `ReactDOM.render(...)` находит в `index.html` файле `div` с `id="root"`, и отрисовывает внутри него все наше приложение.

### Основы JSX

Все "теги", которые мы видим в файле App.js, например `<header>` - это не HTML, а специальный синтаксис, который называется JSX.

Это по сути "синтаксический сахар", который позволяет писать в джаваскрипте структуры, похожие на HTML.
   
В итоге данный код будет скомпилирован в чистый Javascript, в функцию `React.createElement(element, props, children)`, так как браузер умеет работать только с чистым Javascript.    

Вывести переменную в JSX можно с помощью фигурных скобок `{}`. Таким образом можно вывести на экран строку, число или массив. Объект вывести нельзя - будет ошибка. Только какое-то его свойство.

Boolean значения, `null` и `undefined` не рендерятся на экране, вместо них будет пустое место. Благодаря этому, условный рендеринг в JSX (if-else) выглядит следующим образом:
   
```javascript
{user.hasEmail && user.email}
{!user.hasEmail && <span>No email specified</span>}
```

Все теги в JSX обязательно надо закрывать, включая теги `<input>` и `<img>`.

В качестве JSX выражения мы обязаны вернуть только один корневой тег-обертку для всего, что мы пишем. То есть, мы не можем в компоненте вернуть два соседних дива, нам надо обернуть их в третий, и вернуть его. Ошибка называется `JSX expressions must have one parent element`. 

Можно создать либо обертку - `div`, или, если мы не хотим захламлять DOM дерево, обернуть их в `<Fragment>` - специальный технический компонент React, который не будет добавлен в DOM дерево. Существует также более лаконичный синтаксис для создания фрагмента - с помощью `<>...</>`.

### Стилизация в Реакте

Мы можем подключить CSS файлы в React, просто импортировав нужный нам файл в компоненте (код ниже валидный, если CSS файл находится в той же папке, что и компонент):

```
import './App.css';
```

Обратите внимание что мы используем свойство `className` в JSX вместо `class` - потому что `class` - это зарезервированное ключевое слово в Javascript.
   
`create-react-app` по умолчанию поддерживает препроцессор SASS. Чтобы иметь возможность импортировать `sass` файлы в компоненты, нам надо установить библиотеку `node-sass`, дальше все происходит автоматически, и можно в коде напрямую импортировать `sass` файлы.
   
### Компонент в Реакте

Существует два подхода создания компонентов в реакте - функциональные и классовые компоненты. С функциональными компонентами мы будем работать немного позже.
   
Классовый компонент - это обычный класс, который наследуется от `React.Component`, и содержит один обязательный метод - `render()`. Другие методы могут быть или не быть, но рендер должен быть обязательно. И в нем обязательно должен быть прописан `return`.
   
### Работа с состоянием компонента

Каждый компонент может хранить разные переменные в специальном хранилище внутри себя - это называется состояние компонента. 

Начальное состояние компонента можно создавать с помощью `constructor () ...`, а также напрямую прописывая `state = {...}`.
   
```javascript
state = {
  title: 'Hello world'
}
```
   
Прочитать переменную из состояния компонента можно с помощью синтаксиса `this.state.varName` внутри метода `render()` или любого другого метода в компоненте.

Для чтения переменных из состояния компонента всегда используем деструктуризацию. Особенно выгодно это будет когда переменных в состоянии несколько:
   
```javascript
const { title, user } = this.state;
```
   
Для изменения состояния компонента всегда надо использовать функцию `this.setState({prop: newValue})`. Напрямую в текущем состоянии компонента менять что-то нельзя - Реакт не будет правильно работать и не перерендерит ваш компонент.

При каждом изменении состояния компонента он заново рендерится и перерисовывается на экране.

Если случайно написать `setState()` внутри метода `render()`, можно вызвать бесконечный цикл (после `setState()` будет заново вызван `render()`, который опять вызывает `setState()`).

### Продвинутое использование метода setState()

Ранее был рассмотрен пример, в котором внутрь метода `setState()` передавался объект. В таком случае, значение всех ключей из объекта в текущем состоянии компонента будет заменено на новое.

Если новое значение состояния зависит от предыдущего (например, мы увеличиваем счетчик на 1), в качестве первого аргумента в метод `setState()` необходимо передавать фукнцию-callback, которая принимает текущее значение состояния, и возвращает объект с ключами и значениями для изменения текущего состояния:

```javascript
this.setState((current) => {counter: current.counter + 1})
```

Это необходимо для тех редких случаев, когда в коде одно из значений в состоянии компонента может меняться несколько раз. Например, в следующем случае значение переменной `counter` будет увеличено на 1, а не на 2:

```javascript
const { counter } = this.state;

...

this.setState({counter: counter + 1});

...

this.setState({counter: counter + 1});
``` 

Также полезно знать, что метод `setState()` работает асинхронно. То есть, сразу после его вызова (на следующей строке кода) состояние еще может быть не изменено. Чтобы гарантированно выполнить какой-то кусок кода только после того, как значение состояния изменится, мы можем передать в метод второй аргумент. Это функция-callback, которая будет вызвана только после того, как значение в состоянии компонента поменяется:

```javascript
this.setState((current) => {counter: current.counter + 1}, () => {
  console.log('This code will be executed after value in counter will change');
});
```

### React Developer Tools

React Developer Tools - удобный плагин для Chrome, который позволяет инспектировать Реакт компоненты, видеть их состояние и свойства. Для его корректной работы в коде добавлять ничего не нужно. 

### Прочее

При создании собственных методов внутри классового компонента, некоторые из них могут не иметь доступа к переменной `this`. Чтобы исправить это, мы можем:
 - Написать `onClick={this.updateTitle.bind(this)}`. Некрасиво
 - Добавить конструктор, и в нем переопределить функцию, привязав к ней контекст `this.updateTitle = this.updateTitle.bind(this)`
 - Предпочтительный вариант - объявить метод в виде стрелочной функции `updateTitle = () => { this.setState({ title: 'New title' }); }`

Хорошей практикой считается держать `return` в функции `render` минимальным по размеру.
