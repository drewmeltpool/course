## Асинхронные действия (actions), redux-thunk, объединение редьюсеров

### Установка библиотеки redux-thunk

Для работы с асинхронными действиями мы будем использовать библиотеку `redux-thunk`, которая устанавливается с помощью npm. Существуют и другие популярные реализации для создания асинхронных действий, например `redux-saga`, но они более сложные, поэтому мы разберем принципы на более простом варианте.
   
Асинхронные действия позволяют передавать в виде действия функцию, которая содержит много кода, в том числе другие действия.

Без подключения middleware библиотек вроде `redux-thunk`, Redux позволяет отправлять в виде действий только простые объекты, при отправке функции возникнет ошибка.

`middleware` в Redux - это библиотека-прослойка между action и reducer, которая пропускает через себя все действия, и может либо передать их дальше в следующий миддлвер или стор, или остановить передачу действия в стор.

### Подключение библиотеки redux-thunk

Разные библиотеки-middleware можно подключить к проекту с помощью функции `applyMiddleware` из Redux. Чтобы подключить библиотеку `redux-thunk`, но при этом также оставить возможность пользоваться `redux-devtools-extension`, мы можем использовать функцию `compose` (или `composeWithDevTools`):

```js
import { createStore, compose, applyMiddleware } from "redux";
import reducer from './reducer';
import thunk from 'redux-thunk';

const devTools = window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f => f)

const store = createStore(
  reducer,
  compose(applyMiddleware(thunk), devTools)
);
```

### Использование асинхронных действий

Асинхронные действия позволяют передавать в функцию `dispatch` не объект, а функцию. Сама функция должна возвращать другую функцию, которой в качестве первого аргумента будет передана функция `dispatch`, и мы ее сможем вызвать несколько раз внутри нашего асинхронного действия.

Это позволяет вынести всю логику асинхронных эффектов, например, запросов на сервер, в одно асинхронное действие. Пример:

```js
export const loadData = () => (dispatch) => {
  dispatch({ type: LOADING_DATA, payload: true })
  axios('/api/data')
    .then(res => {
      dispatch({ type: SAVE_DATA, payload: res.data })
      dispatch({ type: LOADING_DATA, payload: false })
    })
}
```

Это позволить убрать весь этот код из хука `useEffect` в компоненте, и оставить там вызов только данного асинхронного действия (одна строка кода), что делает код компонента гораздо проще и читабельнее.

### Цепочки асинхронных действий

Мы можем объединять асинхронные действия в цепочки, вызывая одно действие из другого. Например, после регистрации пользователя, мы сразу хотим его залогинить в приложение:

```js
export const loginUser = (user) => (dispatch) => {
  dispatch(...)
}

export const registerUser = (user) => (dispatch) => {
  axios.post(...)
    .then(res => {
      dispatch(...)
      dispatch(loginUser(user))
    })
}
```

### Разделение редьюсеров, объединение с помощью combineReducers
   
Со временем в редьюсере может накопиться очень много бизнес-логики. Один большой файл можно разбить на несколько более мелких файлов, каждый из которых будет отвечать за изменение своей части стора. После этого их можно объединить в главном редьюсере в один большой с помощью функции `combineReducers` из библиотеки `redux`.
   
Имена полей в объекте, который мы передаем внутрь функции `combineReducers` - это будут имена свойств в новом сторе.
   
Функцию `combineReducers` можно использовать и для группировки вложенных свойств - на любом уровне. Таким образом можно объединять редьюсеры в группы.

### Использование библиотеки `immutability-helper` для более удобного обновления состояния стора

Бибилотека `immutability-helper` может быть отдельно установлена для более удобного изменения состояния стора без изменения текущего объекта. Раньше для этого использовалась более старая библиотека `react-addons-update`, но они имеют практически идентичный API.

Библиотека содержит функцию `update`, которая позволяет одновременно изменить несколько свойств объекта, и создать на основании этого новый объект.
