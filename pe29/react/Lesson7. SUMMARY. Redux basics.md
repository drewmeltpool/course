## Основы Redux

### Установка библиотеки Redux

Для начала работы с Redux нам понадобятся следующие библиотеки: `redux`, `react-redux`, `redux-devtools-extension`.
   
Библиотеку Redux в современном мире очень часто используют в связке с Реактом, но это абсолютно независимая библиотека, которую можно использовать для хранения состояния в любом Javascript приложении. Но именно в Реакте она часто приносит максимальную пользу.
   
Мы установили две основные библиотеки - `redux` (это код самой библиотеки) и `react-redux` (это надстройка над библиотекой, которая содержит код и компоненты для подключения библиотеки Redux именно в Реакте).
   
Третья библиотека - `redux-devtools-extension` - нужна для более удобной работы с библиотекой Redux в браузере. В дополнение необходимо установить плагин для Хрома `Redux Devtools Extension`.
   
Сейчас у нас состояние нашего приложения хранится в компоненте App. И все переменные оттуда и функции для изменения компонента нам необходимо прокидывать вниз через все дерево компонентов, включая AppRoutes, что очень неудобно. Библиотека Redux позволяет хранить все состояние приложения в одном месте, отделенном от компонентов, и абсолютно любому компоненту, на любом уровне, подключаться к этому хранилищу.

### Подключение

Как и с большинством других внешних библиотек, чтобы подключить Редакс, нам надо обернуть наше приложение в один дополнительный слой. Делаем мы это внутри главного файла `index.js`.
   
Оборачиваем всю нашу текущую логику в компонент `<Provider>`.

Так как `Provider` - это Реакт компонент, импортируем мы его из библиотеки `react-redux`.

К провайдеру необходимо добавить один обязательный атрибут - `store`. Это и будет наше хранилище. Создается стор с помощью функции `createStore`.

Для создания стора необходима функция-редьюсер, в которой внутри будет прописано изначальное значение стора - что там хранится по умолчанию.
   
Чтобы иметь возможность увидеть текущее состояние стора в браузере, необходимо подключить третью библиотеку -`redux-devtools-extension`. Для ее подключения в функцию `createStore` необходимо передать второй параметр:
   
```js
const store = createStore(
  reducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);
``` 
   
Теперь, если ранее был установлен плагин `Redux Devtools Extension`, в инструментах разработчика браузера должна появиться новая влкадка - `Redux` - с информацией про стор нашего приложения.

### Подключение компонента к Редаксу, чтение данных

Чтобы иметь возможность в компоненте выполнять любые операции со стором, необходимо его перед эспортом обернуть в функцию `connect` из библиотеки `react-redux`.

При этом, чтобы прочитать данные из стора, нам обязательно нужно передать в функцию `connect` первый параметр - функцию `mapStateToProps`.
   
```js
const mapStateToProps = (state) => {
  return {
    ...
  }
}
   
export default connect(mapStateToProps)(Footer)
```
   
На вход в функцию `mapStateToProps` приходит все состояние нашего store. Все что нам нужно сделать - это написать и вернуть какие из свойств в сторе мы хотим использовать в данном компоненте. Мы по сути возвращаем объект с несколькими свойствами из стора. Все эти свойства будут добавлены в `props` нашего компонента.
   
Так как нам свойства приходят в props, мы можем их оттуда достать и отрендерить в любом месте нашего компонента, точно так же, как если бы они были переданы от родительского компонента.
   
При использовании Redux, в самом коде компонента мы работаем со стандартным функционалом Реакта. Компонент даже не знает, подключен ли тут редакс или нет. Нам просто приходят разные props, и внутри компонента мы не знаем, какие из них откуда приходят.
   
Сейчас нам в каждый компонент props могут приходить из трех источников:
 - переданные из родительского компонента
 - добавленные роутером при обертке компонента в `<Route>` или при использовании функции `withRouter()`
 - добавленные в функции `mapStateToProps()`
   
При использовании функции `mapStateToProps()` очень важно импортировать не весь стор в компонент, а только нужные переменные из него. Если импортировать весь стор, то при любом изменении в нем (а там могут быть сотни параметров) компонент будет заново рендериться. А так новый рендер будет происходить только при изменении той части стора, которая непосредственно используется в компоненте.

### Изменение данных в сторе

Для изменения данных в сторе используется такой функционал, как action-ы (действия).
   
Если обернуть компонент в функцию `connect`, ему в `props` придет функция `dispatch`. Это функция, которую мы можем использовать для изменения стора в Редаксе. Чтобы это сделать, нам надо отправить т.н. action - который является простым объектом. У этого объекта могут быть различные свойства, но одно из них является обязательным - свойство `type`. Функция, которая будет отправлять action, может выглядеть следующим образом:
   
```js
const incrementAge = () => {
  dispatch({type: 'INCREMENT_AGE'});
}
```
   
Тип екшена говорит что мы хотим сделать, но не говорит как мы будем это делать.

А реализацию логики данного екшена необходимо прописать в функции-редьюсере. Каждый раз, когда мы отправляем какой-нибудь екшен из любого места приложения, все они попадают в функцию-редьюсер.
   
Функция-редьюсер - это функция, которая знает, каким образом должно меняться состояние приложения в зависимости от того, какие события происходят в приложении. В зависимости от типа каждого екшена нужно каким-то образом модифицировать стор, и вернуть его новое значение.
   
Классический вариант редьюсера прописывается с использованием функционала `switch-case`:
   
```js
const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'INCREMENT_AGE':
      return ...
    case 'ANOTHER_ACTION':
      return ...
    default:
      return state;
  }
}
```
   
Как и с состоянием компонента в Реакте, `state` из Redux store обязательно нужно держать как Immutable - нельзя напрямую менять текущие значения в нем. Вместо изменения свойств существующего объекта, нам всегда надо возвращать новый объект.
   
Первый тестовый екшен `INIT` отправляется самой библиотекой Редакс при старте приложения - именно он заполняет стор значением `initialState` при старте приложения.
   
### Функция mapDispatchToProps

Чтобы упростить код компонентов, мы можем вынести функцию `dispatch` из них. Для этого необходимо передать второй параметр в функцию `connect` - функцию `mapDispatchToProps`. Она похожа на `mapStateToProps`, и тоже возвращает объект, свойства которого будут добавлены в props компонента. Но принимает она на вход функцию `dispatch`, а возвращает функции, которые позволят менять стор (и которые тоже добавляются в props компонента).
   
Если передать в функцию `connect` вторым параметром функцию `mapDispatchToProps`, сама функция `dispatch` больше не будет добавлена в props компонента.

Таким образом, `mapDispatchToProps` позволяет немного разгрузить компонент.
   
Подитожим:
 - Функция `mapStateToProps` используется чтобы читать данные из стора, `mapDispatchToProps` - чтобы менять данные в сторе
 - Что у них общего - и та и та функция возвращает объект, все свойства которого будут добавлены в props компонента
 - `mapStateToProps` возвращает объект со свойствами из стора, `mapDispatchToProps` - объект с функциями для изменения стора
    
А с точки зрения компонента все просто - все эти свойства будут приходить в `props`, независимо от того, из какой функции они были переданы.

### Работа с хуками в библиотеке Redux

Библиотека Redux предоставляет также альтернативный вариант подключения компонента к стору - с использованием хуков.

Вместо использования функции `connect` для оборачивания компонента и функций `mapStateToProps` и `mapDispatchToProps`, мы можем доставать значения из стора и получить доступ к функции `dispatch` прямо внутри компонента. Для этого библиотека Redux предоставляет два хука:
 - useSelector - хук принимает на вход функцию коллбек, и вызывает ее, передав внутрь текущее состояние стора. Возвращает результат вызова функции-коллбека. Пример: `const currentUser = useSelector(state => state.user)`;
 - useDispatch - хук возвращает функцию `dispatch`, которую далее можно использовать в компоненте для отправки action-ов. Пример: `const dispatch = useDispatch();`

На первый взгляд, работать с таким подходом удобнее, но для более сложных случаев, связанных с оптимизацией и тестированием компонента, а также для более крупных компонентов, при использовании данного подхода могут возникнуть дополнительные сложности. 

### debug ошибок при работе с Redux
   
Если при работе с Redux что-то не работает, существует всего 4 места, где могла быть допущена ошибка:
 - Отправление екшена из компонента
 - Редьюсер
 - Функция `mapStateToProps` / `useSelector`
 - Функция render компонента

Чтобы узнать, в каком из мест была допущена ошибка, нужно проверить несколько вещей:
 - При выполнении нужного действия, появился ли новый action в Redux Devtools. Если нет - значит вариант один - мы ошиблись при отправке екшена из компонента
 - Если екшен был отправлен, нажимаем на него и смотрим на его `Diff`. Если diff пустой или не такой как нам надо - значит ошибка точно в функции-редьюсере, ищем там
 - Если дифф правильный, проверяем функцию `mapStateToProps` / `useSelector` и render компонента
   
### Оптимизация кода, best practices
   
Для хранения разных типов файлов логично использовать разные папки. Поэтому для всех элементов, связанных с Redux, можно создать одну общую папку - `store`. Там можно создать файл `store.js`, в котором будет создаваться сам объект `store` с помощью функции `createStore()`.

Типы екшенов всегда выносятся в константы - так мы никогда не допустим ошибок при их написании, в отличие от использования строковых литералов. Иногда для констант также создается отдельный файл, но иногда их пишут в том же файле, что и екшены.

На некоторых проектах может использоваться такой слой, как селекторы. Селектор - это функция, которая принимает на вход все состояние `store`, и возвращает какой-то его кусок, иногда обработанный. Для хранения селекторов обычно используется файл `selectors` внутри папки `store`. Селекторы помогают при наличии более сложных функций, когда, например, в сторе хранится массив, а нам надо найти в нем какое-то одно значение. Либо, если нужно реструктуризовать стор или переименовать в нем какое-то свойство, нам надо будет поменять только один селектор, а не 10 компонентов, которые его используют.

### Разделение файлов по сферам ответственности вместо типа
   
В файле с екшенами пока хранятся все екшены приложения. Сейчас их не много, но в будущем их количество будет стремительно расти, и держать их все в одном файле будет нецелессобразоно. Мы можем применить два подхода по разбивке одного большого файла на подфайлы:
 - Создать несколько файлов в каждой из папок по сферам ответственности. Например создать папку `actions`, и в ней создать файлы `userActions.js`, `emailActions.js`, `appActions.js` и т.д. То же самое будет касаться и других типов файлов
 - Создать для каждой сущности отдельную папку, и вынести весь функционал туда. Например, мы создаем папку `user`, а в нее переносим файлы `actions.js`, `actionTypes.js`, `reducer.js` и т.д.
    
Второй подход считается более универсальным и удобным, особенно на более крупных проектах. Когда у нас будет много таких сущностей - например 10, нам будет гораздо удобно вносить изменения в каждую из сущностей, если все нужные для нее файлы будут лежать в одной папке.
   
### Redux store и состояние компонента

При использовании Редакса мы можем продолжать пользоваться состоянием (state) компонента. Это целесообразно делать, если свойство будет использоваться только в текущем компоненте и никуда не будет передаваться - то есть для самых простых случаев. Например, когда у нас есть компонент с двумя состояниями - expanded/collapsed. Такое свойство можно хранить в state компонента и не передавать в Redux store.

Второй важный момент - надо ли нам сохранять эту информацию при переходе на какую-то другую страницу. Если информация хранится в Редаксе, то при повторном рендере компонента будет использовано сохраненное значение. Если же мы пользуемся state, при повторном рендере будет использовано значение по умолчанию из `useState`.

