## Работа с формами

В чистом React (без подключения библиотек) используются два подхода для работы с формами: контролируемые или неконтролируемые элементы форм.

### Неконтролируемые компоненты

Неконтролируемый элемент формы - это элемент, которому мы не задаем свойств `value` и `onChange`, а значение из него считываем с помощью `ref`:

```js
const loginRef = useRef(null);

...

<input type='text' name='login' placeholder='Login' ref={loginRef} />
```

Чтобы задать значение по умолчанию для какого-то поля (то есть при первом рендере поле уже было заполнено каким-то значением), мы можем использовать атрибут `defaultValue` на теге `input`.

#### Валидация неконтролируемых компонентов

Валидация неконтролируемых компонентов чаще всего реализуется первым действием при сабмите формы (также не забываем отменить перезагрузку страницы с помощью `e.preventDefault()`). Если форма невалидная, то процесс сабмита надо остановить, показав пользователю все ошибки, и не сабмитить форму, пока они все не будут исправлены.

Чтобы все ошибки были показаны в одном стиле, обычно нативную браузерную валидацию отключают, добавив атрибут `noValidate` на тег формы, с которой мы работаем.

Минусы подобной валидации при сабмите формы - она не отзывчивая. Даже после того, как пользователь исправит все ошибки, сообщения об ошибке будут светиться, пока пользователь снова не нажмет на кнопку `Submit`.

### Контролируемые компоненты

Контролируемые элементы формы отличаются от неконтролируемых тем, что им обязательно надо задать два атрибута - `value` и `onChange`. В общем случае рекомендуется работать именно с контролируемыми компонентами.

Контролируемые элементы работают через состояние компонента по следующей схеме:
 - в состоянии компонента (state) создается поле, в котором будет храниться значение инпута
 - в функции `onChange` мы прописываем код, который изменяет нужное поле в состоянии компонента
 - в атрибут `value` мы передаем значение поля из состояния компонента. Выглядит это приблизительно так:

```js
const [values, setValues] = useState({
  login: ''
});

const loginChanged = (e) => {
  setValues({...values, login: e.target.value});
}

...

<input type='email' name='login' value={values.login} onChange={loginChanged} placeholder='Login'></input>
```

При этом можно создать универсальную функцию `handleChange`, которая будет работать для любого инпута (если мы задали ему атрибут `name`):

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setValues({ ...values, [name]: value });
};
```

Чтобы задать значение по умолчанию для какого-то поля, мы можем прописать нужное нам значение внутри хука `useState`.

При работе с контролируемыми элементами, всем элементам формы должно быть задано какое-то значение по умолчанию, отличное от `undefined`, иначе мы получим предупреждение в консоли, что тип нашего элемента меняется с неконтролируемого на контролируемый.

#### Валидация контролируемых компонентов

Так как React в любой момент времени знает значение всех элементов формы, валидацию можно сделать более отзывчивой, и проводить ее при каждом изменении значения любого из элементов формы:

```js
useEffect(() => {
  validateForm(values)
}, [values])
```

Но в такой валидации есть одна проблема. Сразу при запуске приложения у нас уже показываются сообщения об ошибке. А их желательно показывать только после того, как пользователь попытается ввести что-то в поле. Для этого в состоянии компонента можно создать отдельное свойство, которое будет отслеживать, был ли элемент `touched` (то есть пробовал ли пользователь туда что-то ввести). Чтобы отслеживать, когда пользователь уже "побывал" на элементе формы, на все из них надо добавить функцию-хендлер для события `onBlur`.
      
### Работа с библиотекой Formik

Formik - современная и популярная библиотека для работы с формами. Для начала работы с библиотекой, в первую очередь необходимо установить npm пакет `formik`.

Есть два основных способа подключения функционала самой библиотеки:
 - Обернуть код компонента формы в компонент `<Formik>` и передать в качестве атрибутов все конфигурационные параметры. Внутрь него (в children) передать функцию, на вход в котороую будут переданы все свойства формы (т.н. паттерн `render-props`).
 - Обернуть экспорт компонента в HOC `withFormik`, передать в него в виде объекта все конфигурационные параметры. Теперь все свойства формы будут приходить в props нашего компонента.

Также нам необходимо вместо HTML тега `<form>` использовать аналогичный компонент из библиотеки `Formik` - `<Form>`.

Вместо всех тегов `<input>` мы используем компонент `<Field>` из библиотеки `Formik`.

#### Изначальные значения полей в Formik

При использовании библиотеки `Formik`, всем полям формы обязательно нужно указывать значения по умолчанию (как при работе с контролируемыми компонентами). Это можно сделать, передав атрибут `initialValues={{...}}` в компонент `<Formik>`, либо свойство `mapPropsToValues: (props) => {...}` внутрь `withFormik`.

#### Валидация полей в Formik
   
Чтобы подключить функцию валидации в библиотеке `Formik`, мы можем передать атрибут/свойство `validate` в `<Formik>`/`withFormik`. В качестве значения необходимо передать функцию валидации, которая на вход принимает значения всех полей формы, и должна вернуть объект с найденными ошибками.
   
#### Создание валидационной схемы с помощью Yup

Для создания удобной валидационной схемы можно установить npm пакет `yup`. Данная библиотека позволяет создавать простые и читабельные валидационные схемы, которые могут включать проверку всех полей формы на различные условия, и содержат удобные валидационные функции для разных типов данных. Пример подобной схемы:

```js
const formSchema = yup.object().shape({
  login: yup
    .string()
    .required('This field is required')
    .email('Please enter a valid email'),
  password: yup
    .string()
    .required('This field is required')
    .min(8, 'Minimum password length is 8 symbols'),
  confirmPassword: yup
    .string()
    .required('This field is required')
    .oneOf([yup.ref('password')], 'Passwords do not match')
});
```

Библиотека `Formik` включает автоматическую поддержку Yup схем. Чтобы подключить схему, нужно передать свойство `validationSchema` в `<Formik>`/`withFormik`, и в качестве значения передать туда созданную схему. Оба типа валидации (свойства `validate` и `validationSchema`) могут работать параллельно.

#### Submit формы в Formik
   
При сабмите формы, библиотека `Formik` выставляет значение свойства `isSubmitting` в `true`. При этом, если валидация прошла успешно, мы сами должны руками указать, когда сабмит формы закончен (например, после того, как мы успешно отправили данные на сервер и получили ответ). Чтобы иметь удобную возможность это сделать, функция сабмита принимает два аргумента - `values` и `helpers`. В первом из них содержатся значения всех полей формы, а во втором собраны полезные вспомогательные функции для работы с библиотекой, в том числе функция `setSubmitting`. Поэтому в общем случае код по сабмиту формы будет выглядеть приблизительно так:

```js
const handleSubmit = (values, { setSubmitting }) => {
  axios.post('your-server-url', values)
    .then(res => setSubmitting(false))
};
```

#### Использование собственного компонента "input" в Formik

Мы можем использовать собственный компонент `MyInput` при работе с `Formik`.

Один из вариантов - передать его в качестве значения для атрибута `component` в компоненте `<Field>`:

```js
<Field component={MyInput} type='email' name='login' placeholder='Login'></Field>
```

В таком случае библиотека передаст в наш компонент два свойства - `field` и `form`. Свойство `field`  содержит все свойства, которые нам надо добавить к нашему тегу `<input>` для его корректной работы (`value`, `onChange`, `onBlur` и т.д.). Свойство `form` содержит свойства всей формы. В данном случае наш компонент может выглядеть следующим образом:

```js
function MyInput(props) {
  const { field, form, ...rest } = props;
  const { name } = field;

  return (
    <div>
      <input {...field} {...rest} />
      {
        form.touched[name] && form.errors[name] && (
          <span className='error'>{form.errors[name]}</span>
        )
      }
    </div>
  )
}
```

Второй вариант - напрямую использовать наш компонент внутри формы:

```js
<MyInput type='email' name='login' placeholder='Login'></MyInput>
```

При этом, для подключения компонента к форме внутри него надо использовать хук `useField` из библиотеки `Formik`. Передав внутрь хука `name` текущего компонента, мы получим из него в виде массива три объекта:
 - свойства, которые надо добавить к нашему `<input>` для его корректной работы
 - метаданные нашего поля ввода
 - вспомогательные функции для ручной работы с полем

В таком случае наш компонент может выглядеть следующим образом:

```js
function MyInput(props) {
  const { name, ...rest } = props;
  const [field, meta, helpers] = useField(name);

  return (
    <div>
      <input {...field} {...rest} />
      {
        meta.touched && meta.error && (
          <span className='error'>{meta.error}</span>
        )
      }
    </div>
  )
}
```

### Вывод
   
С библиотекой `Formik` работать удобнее и проще всего. Кроме того, это самая популярная библиотека для работы с формами на сегодняшний день. Код весит в два раза меньше кода библиотеки `Redux Form`, а в сочетании с `Yup` позволяет очень просто и читабельно проводить валидацию. Также он лучше с точки зрения производительности. Детальнее это описано на первой странице [документации библиотеки](https://formik.org/docs/overview) в разделах `Motivation` и `Why not Redux-Form?`.
