## Стилизация React компонентов, Material UI

### Продвинутые способы стилизации React компонентов

Ранее мы использовали SASS или чистый CSS для стилизации компонентов. Но при таком подходе может возникнуть проблема со скоупингом - в разных компонентах могут использоваться классы с одинаковым именем. В итоге, в результате коллизии, приложение не будет работать так как нужно, так как весь CSS код будет собран в один файл, и код из одного класса будет перебивать код класса с таким же именем из другого компонента.

Один из вариантов избежать этой проблемы - использовать БЭМ или просто писать все подклассы внутри одного главного класса с именем компонента. То есть, если мы создаем компонент `<Button>`, то стили в соответствующем SCSS файле могут быть прописаны следующим образом:

```scss
.button {
  // Вариант 1. Использование БЭМ. 
  &--black {
    background-color: #555;
    color: #fff;
  }
  
  // Вариант 2. Если мы используем любую другую методологию именования классов, просто пишем все классы внутри класса .button 
  .extended {
    width: 100px;
  }
}
```

Но даже при использовании такого подхода все равно остается риск, что в каком-то из компонентов правило может быть нарушено (например, если у нас будет два компонента с похожим именем), и стили в проекте будут поломаны. Чтобы полностью убрать возможность возникновения данных проблем, существуют альтернативные способы стилизации.

### CSS модули

Данный подход аналогичен использованию чистого SCSS с единственной разницей - все стили разных компонентов будут автоматически иметь свой собственный scope - и даже если в разных компонентах встретится класс с одинаковым именем, то к нему добавится уникальный префикс и суффикс, и в итоге коллизии не будет.
   
Последняя версия `create-react-app` поддерживае CSS модули автоматически. Единственное, что нам нужно сделать - это правильно назвать файл со стилями - с суффиксом `.module.scss`.
   
Теперь, чтобы использовать стили из подобного файла, нам нужно будет импортировать его содержимое в компоненте. На вход придет объект, ключами которого будут прописанные в SCSS имена классов, а значениями - автоматически сгенерированное уникальное имя класса с префиксом и суффиксом, которое надо будет использовать в компоненте.

Если добавить в SCSS файле префикс `:global` перед именем класса, для такого класса не будет создан уникальный класс, его можно будет использовать по такому же имени. Но на практике в файле CSS модуля лучше не писать глобальные стили - их стоит вынести в одно общее место, например, в какую-нибудь подпапку внутри папки `src` (например, `src/theme/styles`).

Для более удобной работы с классами, когда нам нужно присвоить несколько классов какому-то компоненту при определенном условии, можно использовать библиотеку [classnames](https://www.npmjs.com/package/classnames) или [clsx](https://www.npmjs.com/package/clsx). Они позволяют прописывать более удобную комбинацию различных классов и условий их применения.
   
Основной вывод - при выборе стилизации с помощью SCSS, лучше использовать CSS модули для написания стилей отдельных компонентов.

### Styled components

Данный способ стилизации предполагает написание всех CSS стилей для компонента в одной большой шаблонной строке в Javascript. Данный подход не использует классы на уровне нашего кода, а потому коллизии в нем тоже невозможны.

Для каждого компонента, который мы хотим стилизовать, создается отдельная обертка, в которой напрямую прописываются стили, которые должны быть применены к данному компоненту. Если часть стилей будет зависеть от переданных свойств (props) компонента, их можно включить в стили, используя переменную и функцию `css` внутри шаблонной строки:
   
```javascript
import styled, { css } from 'styled-components';
   
const StyledTitle = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
   
  ${props => props.primary && css`
    background: green;
    color: palevioletred;
  `}
`;
   
export default StyledTitle;
```
   
В коде выше можно сразу увидеть и использование обычных стилей, и использование "условных" стилей в зависимости от значения тех или иных переменных внутри props компонента.
   
Плюсы такого подхода - автоматический скоупинг, а также возможность не использовать классы вообще, а напрямую писать CSS стили для каждого компонента в зависимости от его props. 

Минусы - данный код не так удобно писать и поддерживать - так как мы по сути пишем все стили в одной большой шаблонной строке. Можно установить специальный плагин для IDE, который будет автодополнять имена классов и показывать допущенные ошибки. Помимо этого, для любого тега в компоненте (например, дял каждого `<div>`), к которому мы захотим применить какие-то стили, необходимо будет создавать отдельную обертку.

### JSS и Material UI

[Material UI](https://material-ui.com/) - библиотека React компонентов. Она позволяет подключать и использовать готовые React компоненты и стили для них. Все компоненты сделаны по принципу Mobile first, более комплексные компоненты включают как Desktop, так и мобильную версию.

Установка и подключение библиотеки к проекту детально описаны [здесь](https://material-ui.com/getting-started/installation/).

Для стилизации компонентов библиотека использует подход JSS. Все стили прописаны в Javascript коде, и создаются с помощью функции `makeStyles`. При написании стилей, библиотека предоставляет один общий конфигурируемый объект `theme`, который содержит все переменные с цветами, шрифтами, медиа-запросами и т.д., которые можно удобно использовать во всех компонентах.

Библиотека Material UI содержит [шаблоны](https://material-ui.com/getting-started/templates/) готовых страниц, которые позволяют быстро с нуля создать структуру любого приложения.
   
Для знакомства с библиотекой вам понадобятся два основных раздела из документации:
 - `Components` - это готовые примеры использования компонентов. Знакомство с библиотекой лучше начинать с них - просто пролистать весь список, и посмотреть какие вообще компоненты есть в библиотеке. После этого можно начинать работать с конкретными из них, которые вам нужны в данный момент.
 - `Component API` - это техническая документация по каждому компоненту. После того, как мы посмотрели примеры выше и нашли сам нужный компонент и как он используется в связке с другими компонентами, в этом разделе документации можно увидеть, какие свойства есть у каждого компонента, и как переопределять стили для более сложных структур, которые создают несколько элементов в ДОМ дереве, вроде инпутов.

### Деплоймент приложения

Чтобы развернуть React приложение на удаленном хостинге, необходимо использовать сервер, который будет раздавать все файлы для работы фронт-енда (скомпилированные версии HTML, CSS и JS). Для этого можно использовать как обычный статический сервер для раздачи файлов (если в проекте нет бекенда), например, предоставляемый библиотекой `serve`, так и полноценный веб-сервер, который будет являться бекендом для нашего приложения.

1. Чтобы развернуть на сервере [Heroku](https://www.heroku.com/) React Приложение без бекенда, мы можем добавить в корневой папке файл `Procfile` (без расширения - это конфигурационный файл для Heroku) со следующим содержимым:

   ```
   web: npm install -g serve; npm install; npm run build; serve -s build -l $PORT
   ```
   
   Теперь, когда код проекта будет добавлен на Heroku (с помощью Heroku CLI или через Github), код из главной ветки автоматически будет развернут на сервере.
   
2. Чтобы развернуть на Heroku код приложения, которое содержит бекенд, необходимо выполнить несколько дополнительных действий. Структура команд ниже основывается на предположении, что корень проекта содержит две папки `server` и `frontend`:
    - Скомпилировать все фронт-енд файлы с помощью команды `npm run build`, и поместить содержимое папки `build` в какую-нибудь подпапку папки с бекендом, например `public`
    - Настроить бекенд таким образом, чтобы он раздавал статические ресурсы из папки `public`. При использовании сервера Express на Node.js, это делается с помощью команды `app.use(express.static(__dirname + '/public'))`
    - В Procfile прописать следующую команду `web: npm start --prefix server` (при условии что бекенд лежит в папке `server`)
    - Залить весь код на Heroku с помощью Heroku CLI или через Github
         
   После этого код должен быть автоматически развернут на сервере.
   
   Чтобы деплоймент приложения работал без Procfile, а также чтобы нам не нужно было при любом изменении на фронт-енде руками компилировать фронт-енд код и копировать его из папки `build`, мы можем создать в корне проекта новый файл `package.json` с двумя скриптами - `build` и `start`, которые сделают это за нас автоматически:
   
   ```json
   "build": "npm i --prefix server && npm i --prefix frontend && npm run build --prefix frontend && rm -rf server/public/* && cp -a frontend/build/. server/public/",
   "start": "npm start --prefix server",
   ```
      
   Создав файл `package.json` в корне проекта, мы автоматически говорим Heroku, что бекенд написан на Node.js, поэтому Heroku постарается локально запустить скрипт `build` из него, а потом скрипт `start`. При этом файл `Procfile` более будет не нужен.
   
   После этого весь процесс сборки проекта будет проходить автоматически, как только мы запушим код на Heroku.
