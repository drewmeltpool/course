## Тестирование в Реакте

### Тестирование и типы тестов

Тесты нужны не только для того, чтобы найти и исправить ошибки в приложении при разработке нового функционала. Тесты очень часто помогают при рефакторинге кода убедиться, что мы ничего не сломали.

Самы часто встречаемые типы тестов:

- Unit тесты - тестирование отдельных модулей приложения или участков кода независимо от других частей приложения. Такие тесты чаще всего пишут разработчики
- Smoke тесты - простые тесты, которые проверяют, что функционал в целом работает и запускается без ошибок, без проверки какой-либо бизнес-логики
- Интеграционные тесты - более комплексные тесты, которые проверят взаимодействие всех слоев системы (в отличие от юнит тестов)
- End-to-end тесты - тесты, которые симулируют действия реального пользователя. Обычно запускается специальная программа в браузере (или которая содержит движок браузера внутри себя), которая имитирует действия пользователей - клики мышкой, ввод текста и т.д. Подобные действия можно делать с помощью библиотек вроде Selenium или Cypress. Такие тесты чаще всего пишут automation тестировщики

### Использование Jest в приложении create-react-app

В create-react-app Jest уже подключен по умолчанию, его устанавливать и импортировать не нужно (хоть его и нет в зависимостях в `package.json`). В зависимостях в `package.json` есть другие библиотеки для тестирования, но они являются вспомогательными для Jest-a.

Также в `package.json` есть скрипт `test`, который позволяет запустить все тесты в приложении. Сразу при создании приложения в нем уже прописан один готовый тест - в файле `App.test.js`. После подключения роутера и Редакса этот тест, скорее всего, будет падать с ошибкой, поэтому его можно удалить или код внутри него закомментировать.

При запуске команды `npm test` тесты запускаются в watch режиме - по умолчанию только файлы, измененные с момента последнего коммита. Все тесты могут прогоняться долго, поэтому по умолчанию запускаются только тесты для того кода, который мы поменяли.

В create-react-app тестами считаются три типа файлов:
 - Любые `.js` файлы, которые лежат в папке `__tests__` (таких папок может быть много в любом месте проекта). Обычно эту папку кладут внутрь папки `src`, и в этой папке держат глобальные / интеграционные тесты, которые относятся в целом ко всему проекту, а не к конкретному файлу/компоненту
 - Файлы с суффиксом `.test.js` - прописываются рядом с файлом/компонентом, который мы тестируем
 - Файлы с суффиксом `.spec.js` - прописываются рядом с файлом/компонентом, который мы тестируем

### Основы тестирования с помощью Jest

Большинство библиотек для тестирования Javascript кода имеют схожий функционал и синтаксис. Функции, которые мы будем рассматривать, выглядят плюс-минус одинаково во всех библиотеках.

Для создания группы тестов (т.н. "Test suite") используется функция `describe`.

Для создания отдельного теста используется функция `test` или `it`. Jest поддерживает оба варианта.

Никакие из функций Jest при использовании импортировать не нужно, они доступны глобально.

Jest содержит свой environment `jsdom`, который является очень хорошей эмуляцией работы браузера.

Простой тест функции `sum` на Jest может выглядет следующим образом:

```js
test('1 + 2 should equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});

```

### Тестирование Javascript кода в React проектах

При работе с Реактом мы будем тестировать два типа файлов:
 - Обычные JavaScript функции
 - React компоненты

Примером функции для тестирования может быть функция-редьюсер.

При тестировании любой функции необходимо проверить все возможные пути ее ветвления (если она содержит логические конструкции вроде if-else). Для этого на одну функцию мы можем написать несколько тестов.

Первым делом в тестовый файл необходимо импортировать функцию, которую нужно протестировать, и потом уже писать остальной код.

В рамках одного теста может быть несколько функций `expect`.

Имя теста должно быть понятным для чтения - чтобы когда тест упадет, мы четко знали что произошло, и не надо было бы лезть в код и разбираться.

### Матчеры в Jest

Jest содержит много удобных матчеров для проверки различных условий. Их список можно найти на странице документации https://jestjs.io/docs/en/expect

### Тестирование React компонентов

Чтобы протестировать Реакт компонент, его вначале надо отрендерить в рамках теста. Для этого ноебходимо выполнить несколько действий:
 - Создать тестовый файл рядом с компонентом
 - Импортировать компонент в файл с тестом
 - Создать контейнер (`div`) и отрендерить в нем компонент с помощью функции `render` из библиотеки `react-dom`
 - Обернуть рендер компонента в функцию `act`, которая позволяет лучше работать с асинхронными операциями
 - Отрендерить компонент, найти нужны элементы в DOM дереве, и проверить, что все необходимые элементы находятся на экране
 - Если элемент принимает несколько пропсов, на каждый из них желательно написать отдельный тест (либо можно несколько проверок объединить в одном тесте если это целесообразно)
 - Очищать и инициилизировать контейнер после каждого теста с помощью вспомогательных функций `beforeEach`, `afterEach`. Существуют также функции `beforeAll`, `afterAll` для выполнения кода перед/после всех тестов в файле

### Использование @testing-library/react
  
Одна из вспомогательных библиотек, которые установлены при создании приложения с помощью `create-react-app` - `@testing-library/react`. Документацию библиотеки можно найти [здесь](https://github.com/testing-library/react-testing-library). Главное, что нам дает эта библиотека - более удобная функция `render`.

Что позволяет сделать данная библиотека:
 - Больше не нужно руками создавать контейнер, в котором будет рендериться компонент
 - Больше не нужны функции `beforeEach` и `afterEach` - библиотека вызывает их самостоятельно после каждого теста
 - Больше не нужна функция `act` - библиотека уже использует ее внутри
 - Функция `render` возвращает ряд более удобных функций для поиска элементов в отрендеренном контейнере. Их список можно найти [здесь](https://testing-library.com/docs/queries/about). 
 - Функция `render` также может вернуть контейнер, внутри которого был отренедерен элемент

### Использование @testing-library/jest-dom

Еще одна сразу установленная библиотека - `@testing-library/jest-dom`. Ее документация находится [здесь](https://github.com/testing-library/jest-dom). Она позволяет добавить новые удобные матчеры в Jest.

Библиотека подключается в файле `setupTests.js`. Код из этого файла запускается перед выполнением всех тестов, и позволяет их сконфигурировать - тут можно прописывать глобальные настройки для всех тестов.

### Тестирование снепшотами

Cнепшот - это снимок отрендеренного HTML кода компонента. Снимки можно делать, когда мы закончили работу над компонентом, и не ожидаем, что он будет меняться в будущем.

Для тестирования снепшотами Jest содержит две функции:
 - `toMatchSnapshot()` - создает папку `__snapshots__` рядом с файлом теста при первом запуске. При последующих запусках сравнивает сохраненный снепшот с отрендеренным компонентом. При изменении кода компонента, обновить снепшот можно, нажав `u` после того, как тест упадет.
 - `toMatchInlineSnapshot()` - создает такой же снепшот, только внутри вызываемой функции, а не в отдельном файле. В текущей версии React/Jest функция `toMatchInlineSnapshot()` внутри себя использует библиотеку `prettier`, но она не включена в ряд зависимостей. Поэтому при использовании функции мы сразу же увидим ошибку - что библиотека не найдена. Ошибку можно исправить, доустановив библиотеку с помощью команды `npm i prettier`.

### Мок функции

Мок функция - это своего рода "пустышка", функция без реализации, которую мы можем передать в Реакт компонент, чтобы не использовать код реальной функции и чтобы тестировать код компонента без привязки к внешним зависимостям. Так мы ограничиваем зависимости и тестируем только тот кусок кода, который нам нужен. В Реакте чаще всего моки используются для двух вещей:
 - Вложенные компоненты
 - Внешние функции

Для создания мок-функции используется команда `jest.fn()`.

Jest содержит ряд матчеров, которые предназначены специально для работы с мок-функциями https://jestjs.io/docs/en/expect (от `.toHaveBeenCalled()` до `.toHaveNthReturnedWith()`). Также есть специальный [API](https://jestjs.io/docs/en/mock-function-api) для работы с мок-функциями.

### Создание браузерных событий

При написании тестов мы можем имитировать браузерные события (клик на кнопку, ввод текста в поле ввода и т.д.). Это можно сделать несколькими способами:
 - Использовать на элементе функцию `element.dispatchEvent(event)` из чистого Javascript, передав внутрь нужное событие
 - Использовать функцию `fireEvent` из `react-testing-library`
 - Использовать функцию `userEvent` из библиотеки `@testing-library/user-event`

### Мок вложенных компонентов

Мы можем также создавать моки для вложенных компонентов. По умолчанию, при рендере любого компонента, будут отрендерены и все его дочерние компоненты. Но тогда, если ошибка содержится в одном из дочерних компонентов, упадет тест родительского компонента, и будет не очевидно где именно произошла ошибка. Поэтому, чтобы протестировать только код конкретного компонента, и не затрагивать его дочерние компоненты, вместо них можно использовать мок функции.

Создать подобную мок функцию мы можем с помощью команды `jest.mock()`. Внутрь надо передать адрес, который мы хотим "замокать", и предоставить какую-то простую моковую реализацию дочернего компонента, например:

```js
jest.mock('../Icon/Icon', () => (props) => <>Icon</>)
```

### Enzyme и shallow rendering

Раньше вместо Testing library при тестировании Реакт компонентов в связке с Jest чаще всего использовалась библиотека `Enzyme`. Она устанавливается вместе с адаптером для конкретной версии Реакта.

Enzyme содержит очень удобную функцию `shallow()`, которая позволяет отрендерить компонент без вложенных компонентов, то есть нам не надо создавать вручную мок для каждого из них.

Функция `shallow()`  возвращает объект типа `Enzyme shallow wrapper`. API по работе с ним можно найти [здесь](https://enzymejs.github.io/enzyme/docs/api/shallow.html). Один из самых часто используемых методов - `find(selector)`.

### Мок библиотек Redux

Если нам необходимо протестировать компонент, в котором используется функционал Redux, перед рендером компонент необходимо обернуть в компонент `<Provider>`, и передать ему мок store. Более детальную информацию по тестированию компонентов, подключенных к Redux, и асинхронных экшенов, можно найти [здесь](https://redux.js.org/recipes/writing-tests). В частности, для мока Redux store используется библиотека [redux-mock-store](https://github.com/reduxjs/redux-mock-store).

### Мок библиотеки React Router

Если нам необходимо протестировать компонент, в котором используется функционал роутера, нам может понадобиться создать мок для компонента `<Link>` и для функции `withRouter`. Это делается следующим образом:

```js
jest.mock('react-router-dom', () => ({
  Link: 'a',
  withRouter: (Component) => (props) => <Component {...props} />
}))
```

### Подсчет покрытия кода тестами

Подсчет покрытия кода тестами используется, чтобы найти строки кода, которые не были протестированы. Jest предоставляет автоматический подсчет покрытия кода тестами с помощью команды `npm test -- --coverage`.
