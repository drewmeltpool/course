## Продвинутые хуки, оптимизация React приложения, Context API

### Хук useReducer

Данный хук - практически то же самое, что и `useState`, но позволяет передать более сложную функцию-редьюсер для изменения состояния компонента. На практике его можно использовать, если у нас небольшое приложение, и мы не хотим подключать Редакс.
   
На вход хук принимает два параметра - функцию-редьюсер, и изначальное состояние. Функция-редьюсер будет выглядеть точно так же, как и в Redux (на вход мы получаем `state` и `action`, должны вернуть новый `state`).

Хук возвращает массив из двух значений - переменная, которая хранит текущее состояние компонента, и функция `dispatch` для его изменения. При вызове функции `dispatch`, нам внутрь нее нужно передать объект - `action` - который попадет в функцию-редьюсер.

Основные нюансы использования данного хука:
 - хук похож на `useState`, но вместо второй функции-сеттера нам приходит функция-диспатчер, в которую мы будем отправлять екшен, точно так же как в Редаксе
 - в качестве первого параметра в хук мы передаем нашу функцию-редьюсер
 - задание значения по умолчанию в стейте происходит не совсем так как в Редаксе. В Редаксе мы могли в редьюсере прописать `initialState` в первом аргументе функции-редьюсера. Здесь его надо обязательно передать вторым параметром в сам хук, иначе там на старте будет `undefined`, что особенно плохо при работе с массивами

Важный момент по данному хуку - он не поддерживает асинхронные екшены. Этот функционал можно добавить с помощью одной из вспомогательных библиотек, например [этой](https://github.com/dai-shi/use-reducer-async). Но данный факт делает этот хук гораздо менее полезным на практике.
    
На практике данный хук используется редко, так как сохранение сложных объектов в стейте одного компонента - это скорее антипаттерн. Но тем не менее можно встретить его использование вместе с Context API, и о нем нужно знать.

### Оптимизация производительности

При работе с React оптимизация производительности включает два основных момента:
 - уменьшение количество вызовов функций `render` в целом в приложении
 - уменьшение количества сложных вычислений
 - оптимизация использования памяти, чтобы не создавать в ней большое количество короткоживущих объектов

### memo()

По умолчанию, при перерендере родительского компонента, все его дочерние компоненты также будут перерендерены. То есть, если в большом приложении будет перерендерен компонент `<App>`, то функция рендера будет вызвана абсолютно во всех остальных компонентах приложения.

Чтобы избежать лишних рендеров, мы можем обернуть экспорт свех компонентов в HOC `memo()`. `memo()` - это почти что аналог `PureComponent` для классовых компонентов (хотя там есть небольшие различия). https://ru.reactjs.org/docs/react-api.html#reactmemo
   
Он поверхностно сравнивает вложенные объекты в объекте props. Если вы хотите контролировать сравнение, вы можете передать свою функцию сравнения в качестве второго аргумента.

Соответственно, если props компонента не поменялись - то он, а также все его дочерние компоненты, не будут перерендерены.
   
Вывод - на практике часто все компоненты в приложении оборачивают в `memo()`.

Но если на вход в компонент приходит объект, массив или функция, при изменении ссылки на них (даже если внутри содержимое то же самое), React будет считать, что props компонента изменились.
   
### Хук useMemo()

Если мы создаем массив или объект внутри компонента, то каждый раз при выполнении функции `render` старый массив/объект будет уничтожен, и вместо него будет создан новый, даже если результат операции будет тот же самый.

Чтобы не создавать новые одинаковые сущности при каждом рендере, у нас есть два варианта как оптимизировать код:
 - Вынести создание массива/объекта за пределы компонента. Если это возможно сделать (для создания не нужны никакие переменные из компонента), то это самый лучший и рекомендуемый способ
 - Часто мы не можем воспользоваться первым способом, так как для создания массива, например, нам будут нужны переменные из props компонента. В таком случае мы можем обернуть создание объекта или массива в хук `useMemo()`.

Данный хук принимает на вход два параметра - функцию, которая возвращает нужный нам объект, а также массив зависимостей. Массив зависимостей работает точно так же, как и для хука `useEffect`. Пока ни одно значение в массиве зависимостей не поменяется, функция внутри хука не будет повторно вызвана, а при перерендере компонента будет использовано старое мемоизированное (сохраненное в памяти) значение.

Также хук `useMemo` можно использовать для более сложных операций, когда происходит какое-то сложное вычисление, которое требует много времени или итераций.
   
Один из потенциальных примеров использования данного хука - большая функция `[].map...` или работа с крупыми массивами. Использование мемоизации может сократить время работы программы на сотни и тысячи операций в рамках каждого рендера.

### Хук useCallback()

Аналогично объектам и массивам, если мы создаем функцию внутри функционального компонента, то при каждом его рендере будет создан новый экземпляр функции, а старый - удален.

Если подобную функцию передать в качестве атрибута в дочерний компонент, то дочерний компонент будет перерендериться каждый раз при перерендере родительского компонента, так как React будет считать, что компоненту в props пришла новая функция. Особенные проблемы это может вызвать, если данная функция будет использована внутри хука `useEffect` внутри дочернего компонента, а также передана в его массив зависимостей. В некоторых ситуациях это даже может вызвать бесконечный цикл.
      
Чтобы этого избежать, мы можем обернуть объявление любой функции в хук `useCallback()`.

Точно так же как и `useMemo`, данный хук принимает на вход два параметра - функцию, которую мы хотим создать, а также массив зависимостей. Пока ни одно значение в массиве зависимостей не поменяется, новый экземпляр функции не будет создан.

Как легко запомнить разницу между `useMemo` и `useCallback` и когда что использовать: первый хук возвращает объект, второй - функцию, которую потом можно где-то вызвать.
   
В `useCallback` желательно оборачивать все функции-хендлеры, которые мы создаем в компоненте, чтобы они не создавались заново при перерендере.
   
**ВАЖНО!** Если в `useMemo` или `useCallback` не передать второй параметр, то это будет аналогино вызову содержимого БЕЗ данных функций, то есть никакой мемоизации не будет.

### Внешние библиотеки для мемоизации
   
Мы не можем использовать хуки вне компонентов, а значит мы не сможем мемоизировать какие-то сложные утилитные функции, которые объявлены вне компонента. Для этого можно использовать разные сторонние библиотеки. Например - `memoize-one`. https://github.com/alexreardon/memoize-one
   
Это внешняя библиотека, которая позволяет мемоизировать функцию с последним переданым аргументом.

### Хук useImperativeHandle
   
https://ru.reactjs.org/docs/hooks-reference.html#useimperativehandle
   
Данный хук позволяет родительскому компоненту использовать `ref`, объявленный внутри дочернего компонента. Это может понадобиться, например, когда мы создаем собственный инпут, и хотим дать возможность использовать его `ref` родительскому компоненту. Вообще такого кода желательно избегать, но он может использоваться при написании различных библиотек компонентов (например, если вы создаете аналог библиотеки Material UI).

### Хук useLayoutEffect

Данный хук аналогичен хуку `useEffect` с одним отличием - он работает синхронно. С точки зрения кода он используется точно так же, как и `useEffect`.

Схема работы хука `useEffect`:

1. Мы запускаем перерендер компонента (например, изменился state или props)
2. React выполняет код из функции render
3. Картинка на экране обновляется
4. ПОСЛЕ этого запускается код внутри `useEffect` (что потенциально может вызвать еще один рендер компонента)

При этом `useLayoutEffect` отрабатывает синхронно после рендера, но перед обновлением картинки на экране. Схема работы хука `useLayoutEffect`:

1. Мы запускаем перерендер компонента (например, изменился state или props)
2. React выполняет код из функции render
3. Запускается код внутри `useLayoutEffect`, React ждет пока код закончит выполнение
4. Только ПОСЛЕ этого картинка на экране обновляется

Использовать данный хук можно, например, когда компонент моргает после рендера - когда после выполнения `useEffect` запускается еще один рендер. Но использовать его надо аккуратно, потому что задержка времени показа результатов перерендера пользователю ухудшает UX сайта.

В качестве правила, в 99% случаев нужно использовать `useEffect`, и только если с ним не получается добиться нужного результата, можно попробовать использовать `useLayoutEffect`.

### Context API, хук useContext

Context API - это относительно новый API React, который позволяет напрямую передавать данные из родительского компонента в дочерний компонент любого уровня вложенности, без использования props. Именно с помощью этой технологии работают библиотеки `react-redux` и `react-router`.
   
Ранее эта технология была экспериментальной и не рекомендовалась для использования (кроме случая создания своих библиотек вроде `react-redux`). Начиная с версии React 16.7, это полноценный рабочий API.

### Создание контекста

Чтобы создать контекст, мы можем использовать функцию `createContext` из React. Функция принимает изначальное значения контекста, а возвращает сам объект контекста, который мы позже будет использовать во вложенных компонентах.

При создании контекста, объекту контекста можно задать свойство `displayName` - это позволит сделать его немного более читабельным в React Developer Tools.

Объект контекста содержит внутри себя два подкомпонента - `Provider` и `Consumer`. `Provider` используется в родительских компонентах, чтобы передавать данные в дочерние компоненты. `Consumer` используется в дочерних компонентах, чтобы прочитать данные из контекста.

### Чтение данных из контекста во вложенных компонентах
   
Как только мы создали контекст, мы сразу же можем его использовать, даже если не написали ни одного провайдера. Чтобы использовать контекст, нам нужен компонент, который будет консьюмером. 
   
Consumer — это React-компонент, который подписывается на изменения контекста.

Существует три варианта подписаться на контекст:
 - `MyClass.contextType = MyContext;` - только для классовых компонентов. Используя этот API можно подписаться только на один контекст. Получить контекст в таком случае можно с помощью вызова `this.context` 
 - С помощью Context.Consumer и паттерна `render-props`. Для этого код в return компонента надо обернуть в `<MyContext.Consumer>`, а внутрь передать функцию (паттерн `render-props`), в которую будет передано значение контекста
 - С помощью хука `useContext`. Хук принимает на вход объект контекста, а возвращает текущее значение, которое там хранится. Это самый удобный и практичный вариант.

### Создание провайдеров контекста

Если работать без провайдера, все слушатели всегда будут получать значение по умолчанию, заданное при создании объекта контекста, но не смогут его изменить. Чтобы иметь возможность менять значение в контексте, обязательно нужен провайдер.

Провайдер создается в одном из компонентов верхнего уровня с помощью синтаксиса `<MyContext.Provider value={...}>`. Всем дочерним компонентам при создании в них консьюмера будет доступно значение, которое хранится в данном провайдере.

Приложение может содержать сколько угодно провайдеров одного типа (одного контекста), в одном или в разных компонентах. Консьюмер прочитает значение из ближайшего к нему провайдера. Но в большинстве случаев для контекста одного типа используется один провайдер.

Чтобы иметь возможность менять значение, которое содержит провайдер, в качестве `value` мы можем передать переменную, которая хранится в `state` текущего компонента с провайдером, а также функцию для изменения этого значения. При изменении состояния компонента, провайдер передаст всем дочерним компонентам новое значение.
   
Важные моменты о контексте:
 - При использовании Context API, в приложении может и должно быть несколько независимых друг от друга контекстов. Как разделять данные состояния между контекстами - в целом точно так же, как вы в Редаксе разделяли бы store на разные редьюсеры. Разделение состояния приложение на разные контексты необходимо с точки зрения оптимизации. Как только изменяется значение в провайдере контекста, все дочерние компоненты, подписанные на этот контекст, будут перерендерены. Если в приложении есть всего один контекст, который используется во многих компонентах, то при любом, даже малейшем изменении в нем, все подписанные компоненты будут перерендерены. Если же использовать много разных контекстов, то при изменении значения в одном из них, будут обновлены только те компоненты, которые используют именно этот контекст
 - Сам по себе код, создающий контекст, не хранит значение (кроме задания значения по умолчанию при создании контекста). Контекст - это скорее как интерфейс-транспорт, механизм передачи значения от родительского элемента к дочерним. Значения могут храниться в стейте компонента, который определяет Провайдер. И в рамках одного контекста мы можем создать сколько угодно провайдеров в приложении. Провайдеры желательно выносить в отдельный компонент.

Как технически работает контекст с точки зрения компонента-консьюмера:
 - Как только значение в контексте обновляется, компонент будет заново отрендерен. Это по сути четвертое условие перерендера компонента, наряду с изменением props, state или вызова функции `forceUpdate`
 - Потребитель (включая использование `.contextType` и `useContext`) перерендерится при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью `shouldComponentUpdate`
   
Context API удобен, но не является полноценной заменой библиотеки Redux. Redux со всеми современными паттернами позволяет удобно организовать код и разгрузить наши компоненты от лишней логики, что делает их гораздо более читабельными.
   
### Создание пользовательских хуков

Пользовательский хук - это обычная функция, которая внутри может использовать другие хуки. Они чаще всего используются для вынесения общего кода, который используется в нескольких компонентах, в одно место. Пользовательские хуки — это скорее соглашение, соответствующее дизайну хуков, нежели возможность самого React.

По соглашению, все пользовательские хуки должны начинаться на `use...`. Примером может служить хук `useToggle`:

```javascript
const useToggle = (initial = false) => {
  const [isOpen, setOpen] = useState(initial);
   
  const toggleOpen = () => setOpen(!isOpen);
   
  return [isOpen, toggleOpen, setOpen];
};
```
   
Имея подобный хук, мы можем использовать его в компоненте следующим образом:
   
```javascript
const [showDetails, toggleShowDetails, setShowDetails] = useToggle(false);
```
   
Подобный пользовательский хук можно использовать сколько угодно раз в любых компонентах по всему приложению - он позволяет вынести функцию-хендлер клика (изменения) из компонента в сам хук, тем самым упрощая код компонента.
   
При этом важно заметить, что если мы несколько раз вызываем этот хук в одном компоненте, у каждого из вызовов будет свое состояние. Это аналогично вызову нескольких `useState` подряд в одном компоненте.

Можно использовать и более сложные пользовательские хуки. Чем больше кода содержит пользовательский хук, тем более выгодным будет его использование в компоненте.
